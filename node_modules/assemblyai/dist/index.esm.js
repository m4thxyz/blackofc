import axios, { isAxiosError } from 'axios';
import WebSocket from 'ws';
import { Writable } from 'stream';
import fs from 'fs';

function createAxiosClient(params) {
    const client = axios.create({
        baseURL: params.baseUrl,
        headers: { Authorization: params.apiKey },
    });
    client.interceptors.response.use(undefined, throwApiError);
    return client;
}
function throwApiError(error) {
    var _a, _b;
    if (isAxiosError(error) && ((_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error)) {
        return Promise.reject(new Error(error.response.data.error));
    }
    return Promise.reject(error);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Base class for services that communicate with the API.
 */
class BaseService {
    /**
     * Create a new service.
     * @param params The AxiosInstance to send HTTP requests to the API.
     */
    constructor(client) {
        this.client = client;
    }
}

class LemurService extends BaseService {
    summary(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.post("/lemur/v3/generate/summary", params);
            return data;
        });
    }
    questionAnswer(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.post("/lemur/v3/generate/question-answer", params);
            return data;
        });
    }
    actionItems(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.post("/lemur/v3/generate/action-items", params);
            return data;
        });
    }
    task(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.post("/lemur/v3/generate/task", params);
            return data;
        });
    }
    /**
     * Delete the data for a previously submitted LeMUR request.
     * @param id ID of the LeMUR request
     */
    purgeRequestData(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.delete(`/lemur/v3/${id}`);
            return data;
        });
    }
}

var RealtimeErrorType;
(function (RealtimeErrorType) {
    RealtimeErrorType[RealtimeErrorType["BadSampleRate"] = 4000] = "BadSampleRate";
    RealtimeErrorType[RealtimeErrorType["AuthFailed"] = 4001] = "AuthFailed";
    // Both InsufficientFunds and FreeAccount error use 4002
    RealtimeErrorType[RealtimeErrorType["InsufficientFundsOrFreeAccount"] = 4002] = "InsufficientFundsOrFreeAccount";
    RealtimeErrorType[RealtimeErrorType["NonexistentSessionId"] = 4004] = "NonexistentSessionId";
    RealtimeErrorType[RealtimeErrorType["SessionExpired"] = 4008] = "SessionExpired";
    RealtimeErrorType[RealtimeErrorType["ClosedSession"] = 4010] = "ClosedSession";
    RealtimeErrorType[RealtimeErrorType["RateLimited"] = 4029] = "RateLimited";
    RealtimeErrorType[RealtimeErrorType["UniqueSessionViolation"] = 4030] = "UniqueSessionViolation";
    RealtimeErrorType[RealtimeErrorType["SessionTimeout"] = 4031] = "SessionTimeout";
    RealtimeErrorType[RealtimeErrorType["AudioTooShort"] = 4032] = "AudioTooShort";
    RealtimeErrorType[RealtimeErrorType["AudioTooLong"] = 4033] = "AudioTooLong";
    RealtimeErrorType[RealtimeErrorType["BadJson"] = 4100] = "BadJson";
    RealtimeErrorType[RealtimeErrorType["BadSchema"] = 4101] = "BadSchema";
    RealtimeErrorType[RealtimeErrorType["TooManyStreams"] = 4102] = "TooManyStreams";
    RealtimeErrorType[RealtimeErrorType["Reconnected"] = 4103] = "Reconnected";
    RealtimeErrorType[RealtimeErrorType["ReconnectAttemptsExhausted"] = 1013] = "ReconnectAttemptsExhausted";
})(RealtimeErrorType || (RealtimeErrorType = {}));
const RealtimeErrorMessages = {
    [RealtimeErrorType.BadSampleRate]: "Sample rate must be a positive integer",
    [RealtimeErrorType.AuthFailed]: "Not Authorized",
    [RealtimeErrorType.InsufficientFundsOrFreeAccount]: "Insufficient funds or you are using a free account. This feature is paid-only and requires you to add a credit card. Please visit https://assemblyai.com/dashboard/ to add a credit card to your account.",
    [RealtimeErrorType.NonexistentSessionId]: "Session ID does not exist",
    [RealtimeErrorType.SessionExpired]: "Session has expired",
    [RealtimeErrorType.ClosedSession]: "Session is closed",
    [RealtimeErrorType.RateLimited]: "Rate limited",
    [RealtimeErrorType.UniqueSessionViolation]: "Unique session violation",
    [RealtimeErrorType.SessionTimeout]: "Session Timeout",
    [RealtimeErrorType.AudioTooShort]: "Audio too short",
    [RealtimeErrorType.AudioTooLong]: "Audio too long",
    [RealtimeErrorType.BadJson]: "Bad JSON",
    [RealtimeErrorType.BadSchema]: "Bad schema",
    [RealtimeErrorType.TooManyStreams]: "Too many streams",
    [RealtimeErrorType.Reconnected]: "Reconnected",
    [RealtimeErrorType.ReconnectAttemptsExhausted]: "Reconnect attempts exhausted",
};
class RealtimeError extends Error {
}

const defaultRealtimeUrl = "wss://api.assemblyai.com/v2/realtime/ws";
class RealtimeService {
    constructor(params) {
        var _a, _b, _c;
        this.listeners = {};
        this.realtimeUrl = (_a = params.realtimeUrl) !== null && _a !== void 0 ? _a : defaultRealtimeUrl;
        this.sampleRate = (_b = params.sampleRate) !== null && _b !== void 0 ? _b : 16000;
        this.wordBoost = params.wordBoost;
        this.realtimeUrl = (_c = params.realtimeUrl) !== null && _c !== void 0 ? _c : defaultRealtimeUrl;
        if ("apiKey" in params)
            this.apiKey = params.apiKey;
        if ("token" in params)
            this.token = params.token;
        if (!(this.apiKey || this.token)) {
            throw new Error("API key or temporary token is required.");
        }
    }
    connectionUrl() {
        const url = new URL(this.realtimeUrl);
        if (url.protocol !== "wss:") {
            throw new Error("Invalid protocol, must be wss");
        }
        const searchParams = new URLSearchParams();
        if (this.token) {
            searchParams.set("token", this.token);
        }
        searchParams.set("sample_rate", this.sampleRate.toString());
        if (this.wordBoost && this.wordBoost.length > 0) {
            searchParams.set("word_boost", JSON.stringify(this.wordBoost));
        }
        url.search = searchParams.toString();
        return url;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.listeners[event] = listener;
    }
    connect() {
        return new Promise((resolve) => {
            if (this.socket) {
                throw new Error("Already connected");
            }
            const url = this.connectionUrl();
            let headers;
            if (this.token) {
                headers = undefined;
            }
            else if (this.apiKey) {
                headers = { Authorization: this.apiKey };
            }
            this.socket = new WebSocket(url.toString(), { headers });
            this.socket.onclose = ({ code, reason }) => {
                var _a, _b;
                if (!reason) {
                    if (code in RealtimeErrorType) {
                        reason = RealtimeErrorMessages[code];
                    }
                }
                (_b = (_a = this.listeners).close) === null || _b === void 0 ? void 0 : _b.call(_a, code, reason);
            };
            this.socket.onerror = (errorEvent) => {
                var _a, _b, _c, _d;
                if (errorEvent.error)
                    (_b = (_a = this.listeners).error) === null || _b === void 0 ? void 0 : _b.call(_a, errorEvent.error);
                else
                    (_d = (_c = this.listeners).error) === null || _d === void 0 ? void 0 : _d.call(_c, new Error(errorEvent.message));
            };
            this.socket.onmessage = ({ data }) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
                const message = JSON.parse(data.toString());
                if ("error" in message) {
                    (_b = (_a = this.listeners).error) === null || _b === void 0 ? void 0 : _b.call(_a, new RealtimeError(message.error));
                    return;
                }
                switch (message.message_type) {
                    case "SessionBegins": {
                        const openObject = {
                            sessionId: message.session_id,
                            expiresAt: new Date(message.expires_at),
                        };
                        resolve(openObject);
                        (_d = (_c = this.listeners).open) === null || _d === void 0 ? void 0 : _d.call(_c, openObject);
                        break;
                    }
                    case "PartialTranscript": {
                        // message.created is actually a string when coming from the socket
                        message.created = new Date(message.created);
                        (_f = (_e = this.listeners).transcript) === null || _f === void 0 ? void 0 : _f.call(_e, message);
                        (_h = (_g = this.listeners)["transcript.partial"]) === null || _h === void 0 ? void 0 : _h.call(_g, message);
                        break;
                    }
                    case "FinalTranscript": {
                        // message.created is actually a string when coming from the socket
                        message.created = new Date(message.created);
                        (_k = (_j = this.listeners).transcript) === null || _k === void 0 ? void 0 : _k.call(_j, message);
                        (_m = (_l = this.listeners)["transcript.final"]) === null || _m === void 0 ? void 0 : _m.call(_l, message);
                        break;
                    }
                    case "SessionTerminated": {
                        (_o = this.sessionTerminatedResolve) === null || _o === void 0 ? void 0 : _o.call(this);
                        break;
                    }
                }
            };
        });
    }
    sendAudio(audio) {
        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
            throw new Error("Socket is not open for communication");
        }
        const payload = {
            audio_data: Buffer.from(audio).toString("base64"),
        };
        this.socket.send(JSON.stringify(payload));
    }
    stream() {
        const stream = new Writable({
            write: (chunk, encoding, next) => {
                this.sendAudio(chunk);
                next();
            },
        });
        return stream;
    }
    close(waitForSessionTermination = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.socket) {
                if (this.socket.readyState === WebSocket.OPEN) {
                    const terminateSessionMessage = `{"terminate_session": true}`;
                    if (waitForSessionTermination) {
                        const sessionTerminatedPromise = new Promise((resolve) => {
                            this.sessionTerminatedResolve = resolve;
                        });
                        this.socket.send(terminateSessionMessage);
                        yield sessionTerminatedPromise;
                    }
                    else {
                        this.socket.send(terminateSessionMessage);
                    }
                }
                this.socket.removeAllListeners();
                this.socket.close();
            }
            this.listeners = {};
            this.socket = undefined;
        });
    }
}

class RealtimeServiceFactory {
    constructor(client, params) {
        this.client = client;
        this.params = params;
    }
    createService(params) {
        if (!params)
            params = { apiKey: this.params.apiKey };
        else if (!("token" in params) && !params.apiKey) {
            params.apiKey = this.params.apiKey;
        }
        return new RealtimeService(params);
    }
    createTemporaryToken(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.client.post("/v2/realtime/token", params);
            return response.data.token;
        });
    }
}

class TranscriptService extends BaseService {
    constructor(client, files) {
        super(client);
        this.files = files;
    }
    /**
     * Create a transcript.
     * @param params The parameters to create a transcript.
     * @param options The options used for creating the new transcript.
     * @returns A promise that resolves to the newly created transcript.
     */
    create(params, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const path = getPath(params.audio_url);
            if (path !== null) {
                const uploadUrl = yield this.files.upload(path);
                params.audio_url = uploadUrl;
            }
            const res = yield this.client.post("/v2/transcript", params);
            if ((_a = options === null || options === void 0 ? void 0 : options.poll) !== null && _a !== void 0 ? _a : true) {
                return yield this.poll(res.data.id, options);
            }
            return res.data;
        });
    }
    poll(transcriptId, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = Date.now();
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const transcript = yield this.get(transcriptId);
                if (transcript.status === "completed" || transcript.status === "error") {
                    return transcript;
                }
                else if (Date.now() - startTime <
                    ((_a = options === null || options === void 0 ? void 0 : options.pollingTimeout) !== null && _a !== void 0 ? _a : 180000)) {
                    yield new Promise((resolve) => { var _a; return setTimeout(resolve, (_a = options === null || options === void 0 ? void 0 : options.pollingInterval) !== null && _a !== void 0 ? _a : 3000); });
                }
                else {
                    throw new Error("Polling timeout");
                }
            }
        });
    }
    /**
     * Retrieve a transcript.
     * @param id The identifier of the transcript.
     * @returns A promise that resolves to the transcript.
     */
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.client.get(`/v2/transcript/${id}`);
            return res.data;
        });
    }
    /**
     * Retrieves a page of transcript listings.
     * @param parameters The parameters to filter the transcript list by, or the URL to retrieve the transcript list from.
     */
    list(parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = "/v2/transcript";
            let query;
            if (typeof parameters === "string") {
                url = parameters;
            }
            else if (parameters) {
                query = parameters;
            }
            const { data } = yield this.client.get(url, {
                params: query,
            });
            for (const transcriptListItem of data.transcripts) {
                transcriptListItem.created = new Date(transcriptListItem.created);
                if (transcriptListItem.completed) {
                    transcriptListItem.completed = new Date(transcriptListItem.completed);
                }
            }
            return data;
        });
    }
    /**
     * Delete a transcript
     * @param id The identifier of the transcript.
     * @returns A promise that resolves to the transcript.
     */
    delete(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.client.delete(`/v2/transcript/${id}`);
            return res.data;
        });
    }
    /**
     * Search through the transcript for a specific set of keywords.
     * You can search for individual words, numbers, or phrases containing up to five words or numbers.
     * @param id The identifier of the transcript.
     * @param id Keywords to search for.
     * @return A promise that resolves to the sentences.
     */
    wordSearch(id, words) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.get(`/v2/transcript/${id}/word-search`, {
                params: {
                    words: JSON.stringify(words),
                },
            });
            return data;
        });
    }
    /**
     * Retrieve all sentences of a transcript.
     * @param id The identifier of the transcript.
     * @return A promise that resolves to the sentences.
     */
    sentences(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.get(`/v2/transcript/${id}/sentences`);
            return data;
        });
    }
    /**
     * Retrieve all paragraphs of a transcript.
     * @param id The identifier of the transcript.
     * @return A promise that resolves to the paragraphs.
     */
    paragraphs(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.get(`/v2/transcript/${id}/paragraphs`);
            return data;
        });
    }
    /**
     * Retrieve subtitles of a transcript.
     * @param id The identifier of the transcript.
     * @param format The format of the subtitles.
     * @return A promise that resolves to the subtitles text.
     */
    subtitles(id, format = "srt") {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.get(`/v2/transcript/${id}/${format}`);
            return data;
        });
    }
    /**
     * Retrieve redactions of a transcript.
     * @param id The identifier of the transcript.
     * @return A promise that resolves to the subtitles text.
     */
    redactions(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.client.get(`/v2/transcript/${id}/redacted-audio`);
            return data;
        });
    }
}
function getPath(path) {
    let url;
    try {
        url = new URL(path);
        if (url.protocol === "file:")
            return url.pathname;
        else
            return null;
    }
    catch (_a) {
        return path;
    }
}

class FileService extends BaseService {
    /**
     * Upload a local file to AssemblyAI.
     * @param input The local file path to upload, or a stream or buffer of the file to upload.
     * @return A promise that resolves to the uploaded file URL.
     */
    upload(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileData;
            if (typeof input === "string")
                fileData = fs.createReadStream(input);
            else
                fileData = input;
            const { data } = yield this.client.post("/v2/upload", fileData, {
                headers: {
                    "Content-Type": "application/octet-stream",
                },
            });
            return data.upload_url;
        });
    }
}

class AssemblyAI {
    /**
     * Create a new AssemblyAI client.
     * @param params The parameters for the service, including the API key and base URL, if any.
     */
    constructor(params) {
        params.baseUrl = params.baseUrl || "https://api.assemblyai.com";
        const client = createAxiosClient(params);
        this.files = new FileService(client);
        this.transcripts = new TranscriptService(client, this.files);
        this.lemur = new LemurService(client);
        this.realtime = new RealtimeServiceFactory(client, params);
    }
}

export { AssemblyAI, FileService, LemurService, RealtimeService, RealtimeServiceFactory, TranscriptService };
